# 【基础篇】

## 面向对象

### 什么是面向对象？

**面向对象（Object Oriented）**

- 面向对象程序设计在某种程度上通过强调可重复性，解决了硬件环境逐渐复杂的情况下，让软件得到了良好的维护。
- 简单来说，面向兑现的开发范式中，程序员将问题分解成一个个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象间的调用、组合解决问题。
- 就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成一个对象。然后基于对象和对象的能力进行业务逻辑的实现。比如要造一辆车，上来先把造车需要的属性定义出来，然后抽象成一个car类。

**优点**

- 更加符合人类的思维方式。
- 代码可维护性、可拓展性更高。



*与其说面向对象是一种开发范式，倒不如说面向对象是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，在运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。*



### 面向对象的三大基本特征

#### 封装（Encapsulation）

​	简单的说，一个雷就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，可以给某些代码或数据定义不同级别的保护，防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

例：封装一个类为矩形，定义属性：长、宽

#### 继承（Inheritance）

​	继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

#### 多态（Polymorphism）

​	所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。

​	这意味着，虽然针对不同对象的操作不同，但通过一个公共的类，它们(那些操作)可以通过相同的方式予以调用。

​	最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。



### 面向对象的五大基本原则

#### 单一职责原则

Single-Responsibility Principle

其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。

#### 开放封闭原则

Open-Closed principle

其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。

开放封闭原则主要体现在两个方面：

1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。

2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。

#### 里氏替换原则

Liskov-Substitution Principle

其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

#### 依赖倒置原则

Dependecy-Inversion Principle

其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。

依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。

#### 接口隔离原则

Interface-Segregation Principle

其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。

具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。



### 封装、继承、多态

#### 什么是多态？

什么是多态

多态（Polymorphism）,指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。一般情况下，可以把多态分成以下几类：

- 特设多态：为个体的特定类型的任意集合定义一个共同接口。
- 参数多态：指定一个或多个类型不靠名字而是靠可以标识任何类型的抽象符号。
- 子类型：一个名字指称很多不同的类的实例，这些类有某个共同的超类

**特设多态**

特设多态是程序设计语言的一种多态，多态函数有多个不同的实现，依赖于其实参而调用相应版本的函数。

上一节我们介绍过的函数重载是特设多态的一种，除此之外还有运算符重载也是特设多态的一种。

**参数多态**

参数多态在程序设计语言与类型论中是指声明与定义函数、复合类型、变量时不指定其具体的类型，而把这部分类型作为参数使用，使得该定义对各种具体类型都适用。

参数多态其实也有很广泛的应用，比如Java中的泛型就是参数多态的一种。参数多态另外一个应用比较广泛的地方就是函数式编程。

**子类型**

在面向对象程序设计中，计算机程序运行时，相同的消息可能会送给多个不同的类别之对象，而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。

这种子类型多态其实就是Java中常见的多态，下面我们针对Java中的这种子类型多态展开介绍下。

#### Java中的多态

Java中的多态的概念比较简单，就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

Java中多态其实是一种运行期的状态。为了实现运行期的多态，或者说是动态绑定，需要满足三个条件：

- 有类继承或者接口实现
- 子类要重写父类的方法
- 父类的引用指向子类的对象

**静态多态**

上面我们说多态，是一种运行期概念。还有一种说法认为多态还分为动态多态和静态多态。

上面提到的那种动态绑定认为是动态多态，因为只有在运行期才知道真正调用的是那个类的方法。

有很多人认为，还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为他需要在编译期决定具体调用哪个方法。

**我们总结一下重载和重写这两个概念：**

1. 重载是一个编译期概念、重写是一个运行期概念。
2. 重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。
3. 重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法。
4. Java中的方法重写是Java多态（子类型）的实现方式。而Java中的方法重写其实是特设多态的一种实现方式。

#### 方法重写与重载

重载：指的是在同一个类中，多个函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

方法重载的条件需要具备以下条件和要求：

1. 被重载的方法必须改变参数列表。
2. 被重载的方法可以改变返回类型。
3. 被重载的方法可以改变访问修饰符。
4. 被重载的方法可以声明新的或更广的检查异常。
5. 方法能够在同一个类中或者在一个子类中被重载。
6. 

重写：指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。

方法重写的条件需要具备以下条件和要求：

1. 参数列表必须完全与被重写方法的相同。
2. 返回类型必须完全与被重写方法的返回类型相同。
3. 访问级别的限制性一定不能比被重写方法的强。
4. 访问级别的限制性可以比被重写方法的弱。
5. 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常。
6. 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）。
7. 不能重写被标示为final的方法。
8. 如果不能继承一个方法，则不能重写这个方法。

#### Java的继承与实现

继承（Inheritance）：把多个类功能相同的部分抽象出一个父类，让他们都继承这个类。

实现（Implement）：如果多个类处理的目标是一样的， 但是业务逻辑不同，那就出一个接口，让他们各自实现这个接口。

<!--特别需要注意的是，Java中支持一个类同时实现多个接口，但是不支持同时继承多个类。-->

#### Java的继承与组合

**面向对象的复用技术**

复用性是面向对象技术很好的好处之一。节省开发时间、提升开发效率。

Java代码的复用：继承、组合、代理。

**继承**

我们说继承是类与类或者接口与接口之间最常见的一种关系；继承是一种is-a关系。

> is-a：表示"是一个"的关系，如狗是一个动物

**组合**

组合(Composition)体现的是整体与部分、拥有的关系，即[`has-a`](https://en.wikipedia.org/wiki/Has-a)的关系。

> has-a：表示"有一个"的关系，如狗有一个尾巴



**组合与继承的区别和联系**

**继承（白盒式代码复用）**：

- 父类的内部结构对子类是可见的。（如果父类的实现发生改变，则导致子类行为不可预知性。）
- 写代码时就要确定继承哪个类，编译期就确定了关系，灵活性下降。

**组合（黑盒式代码复用）**：

- 对现有对象进行拼装组合，产生新的，更复杂的功能。各对象的内部细节是不可见的。（组合中一般都定义一个类型，所以在编译期不知道具体会调用哪个实现类的方法）
- 采用面向接口编程，类的关系一般在运行期确定。

**优缺点比较**

| 组 合 关 系                                                  | 继 承 关 系                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立     | 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 |
| 优点：具有较好的可扩展性                                     | 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价         |
| 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 | 缺点：不支持动态继承。在运行时，子类无法选择不同的父类       |
| 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 | 缺点：子类不能改变父类的接口                                 |
| 缺点：整体类不能自动获得和局部类同样的接口                   | 优点：子类能自动继承父类的接口                               |
| 缺点：创建整体类的对象时，需要创建所有局部类的对象           | 优点：创建子类的对象时，无须创建父类的对象                   |

**总结：**

**`建议在同样可行的情况下，优先使用组合而不是继承。`**

**`因为组合更安全，更简单，更灵活，更高效。`**

> 只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在[`is-a`](https://zh.wikipedia.org/wiki/Is-a)关系的时候，类B才应该继承类A。《[Effective Java](http://s.click.taobao.com/t?e=m%3D2%26s%3DwIPn8%2BNPqLwcQipKwQzePOeEDrYVVa64K7Vc7tFgwiHjf2vlNIV67vo5P8BMUBgoUOZr0mLjusdpS4hLH%2FP02ckKYNRBWOBBey11vvWwHXSniyi5vWXIZvgXwmdyquYbNLnO%2BjzYQLqKnzbV%2FMLqnMYMXU3NNCg%2F&pvid=10_125.119.86.125_345_1458652241780)》



#### 构造函数与默认构造函数

创建对象时初始化对象，为对象成员变量赋值初始化，与new运算符一起使用在创建对象的语句中。

```java
/**
* 矩形
*/
class Rectangle {

     /**
      * 构造函数
      */
     public Rectangle(int length, int width) {
         this.length = length;
         this.width = width;
     }
     
     public static void main (String []args){
        //使用构造函数创建对象
        Rectangle rectangle = new Rectangle(10,5);
        
     }
}
```

1. 一个类可以有多个构造函数，根据参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。
2. 构造函数跟一般的实例方法十分相似，但是与其他方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。
3. 构造器的函数名称必须和它所属类的名称相同。
4. 如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成默认构造函数。一般会把成员变量的初始化为默认值。
5. 如果我们手动在某个类定义了一个有参数的构造函数，那么这个默认的无参构造函数就不会自动添加了，需要手动创建。

```java
/**
* 矩形
*/
class Rectangle {

     /**
      * 构造函数
      */
     public Rectangle(int length, int width) {
         this.length = length;
         this.width = width;
     }
     
     /**
      * 无参构造函数
      */
     public Rectangle() {
         
     }
}
```



#### 类变量、成员变量和局部变量

java中有三种变量

类变量 ：方法区

成员变量 ：堆内存

局部变量 ：栈内存

```java
    /**
     * @author Hollis
     */
    public class Variables {
    
        /**
         * 类变量
         */
        private static int a;
    
        /**
         * 成员变量
         */
        private int b;
    
        /**
         * 局部变量
         * @param c
         */
        public void test(int c){
            int d;
        }
    }
```

> 需要注意的是，a，b是共享变量，c，d是非共享变量。只有共享变量会遇到并发问题，遇到多线程场景，对于a，b的操作需要考虑线程安全。



#### 成员变量和方法作用域

我们通过封装的手段，将成员变量、方法等包装在一个类中。那么，类中的这些成员变量和方法，能不能被外部访问？能被谁访问呢？

Java支持4中不同的访问权限：

`public` ：该成员变量或方法对所有类或者对象都是可见的，可以直接访问。

`private` ：该成员变量或方法是私有的，只有当前类有访问权限，除此之外其		他类或者对象都没有权限，子类也不行。
`protected` ：该成员变量或方法对类自身，与同一个包中的其他类可见，其		他包下的类不能访问，除非是他的子类。

| 修饰符    | 区别                                                         |
| :-------- | ------------------------------------------------------------ |
| public    | 所有类或者对象都是可见的，可以直接访问。                     |
| private   | 私有的，只有当前类有访问权限，除此之外其他类或者对象都没有权限，子类也不行。 |
| protected | 所在类和同一个包中的其他类可见，其他包下的类不能访问，除非是他的子类。 |
| default   | 只有自己和其位于同一个包内的可见，其他包内的类不行，包括子类 |



### 平台无关性

#### 平台无关性的实现

Java语言规范、Class文件、Java虚拟机（JVM）等。

#### 编译原理基础

Java到底是是如何运行起来的？

> 计算机只认识0和1，所以，计算机真正执行的是二进制文件。
>
> 我们需要把编写的代码，翻译成二进制文件，这个过程叫做 编译。负责这一过程的工具叫编译器。

Java平台中，想要把Java文件编译成二进制文件，需要经过两步：

**前端编译和后端编译**

![img](https://www.hollischuang.com/wp-content/uploads/2019/03/15539284762449.jpg)

**前端编译**：

**把.java代码转换成.Class代码**。与源语言有关，但是与目标机无关的部分。javac就是前端编译，idea、eclipse等，都内置了前端编译器。

**后端编译**：

**把.Class文件转换成二进制文件。**将中间代码在翻译成机器语言。Java虚拟机来执行。

**![img](https://www.hollischuang.com/wp-content/uploads/2019/03/15539289530245.jpg)**

##### Java虚拟机

Java语言是平台无关的，但是Java虚拟机是需要区分平台的，不同的操作系统对应不同的Java虚拟机。

##### 字节码

各种不同的平台的虚拟机都使用同一的程序存储格式——字节码（ByteCode）是构成平台无关性的另一个基石。Java虚拟机只是由字节码组成的Class文件进行交互。

Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。

##### Java语言规范

保证基本数据类型在所有平台的一致性。

![img](https://www.hollischuang.com/wp-content/uploads/2021/06/Jietu20210627-141259-2.jpg)



##### 小结

对于Java的平台无关性的支持是分布在整个Java体系结构中的。其中扮演着重要的角色的有Java语言规范、Class文件、Java虚拟机等。

- java语言规范
  - 通过规定Java语言中基本数据类型的取值范围和行为。
- Class文件
  - 所有Java文件要编译成统一的Class文件。
- Java虚拟机
  - 通过Java虚拟机将Class文件转成对已你平台的二进制文件等。



#### 值传递、引导传递

##### 实参与形参

参数在程序语言中分为**形式参数和实际参数**

实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。

```java
public static void main(String[] args) {
  ParamTest pt = new ParamTest();
  pt.sout("Hollis");//实际参数为 Hollis
}

public void sout(String name) { //形式参数为 name
  System.out.println(name);
}
```



##### 求值策略

求值策略分为两大基本类，分为严格的和非严格的。多数现存的编程语言对函数都使用严格求值。 

- 传值调用（值传递）

  - 在传值调用中，实际参数先被求值，然后复制该值，被传递给被调用函数的形式参数。因为形参拿到的只是一个“局部拷贝”，所以如果在被调函数中改变了形参的值，但是不改变实际参数的值。

- 传引用调用（引用传递）

  - 在传引用调用中，传递给函数的是实际参数的隐式引用而不是实参的拷贝。因为传递的是引用，所以，如果在被调函数中改变了形式参数的值，对于调用者来说是可见的。

- 传共享对象调用（共享对象传递）

  - 传共享对象调用，先获取到实参地址，然后复制，把改地址的拷贝传递给被调用函数的形参。因此参数的地址都指向同一个对象，所以也称之为“传共享对象”。

    

**其实传共享对象调用和传值调用的过程几乎是一样的，都是进行"求值"、"拷贝"、"传递"。**

但是，传共享对象调用和内传引用调用的结果又是一样的，都是在被调函数中如果改变参数的内容，那么这种改变也会对调用者有影响。

> 那么，共享对象传递和值传递以及引用传递之间到底有什么关系呢？

**传共享对象调用的过程和传值调用的过程是一样的，而且都有一步关键的操作，那就是复制，所以，通常我们认为传共享对象调用是传值调用的特例。**

**传值调用是指在调用函数时将实际参数`复制`一份传递到函数中，传引用调用是指在调用函数时将实际参数的引用`直接`传递到函数中。**

所以，两者的最主要区别就是是直接传递的，还是传递的是一个副本。

这里我们来举一个形象的例子。再来深入理解一下传值调用和传引用调用：

> 1、你有一把钥匙，当你的朋友想要去你家的时候，如果你`直接`把你的钥匙给他了，这就是引用传递。
>
> 这种情况下，如果他对这把钥匙做了什么事情，比如他在钥匙上刻下了自己名字，那么这把钥匙还给你的时候，你自己的钥匙上也会多出他刻的名字。

>2、你有一把钥匙，当你的朋友想要去你家的时候，你`复刻`了一把新钥匙给他，自己的还在自己手里，这就是值传递。
>
>这种情况下，他对这把钥匙做什么都不会影响你手里的这把钥匙。



##### Java中的对象传递

其实Java中使用的求值策略就是传共享对象调用，也就是说，Java会将对象的地址的拷贝传递给被调用函数的形参。只不过“传共享对象调用”这个词不常用，所有通常说”Java是传值调用“，这么说也没错，因为传共享对象调用其实是传值调用的一个特例。



**值传递和共享对象传递的现象冲突吗？**

不冲突，传递共享对象实际上是将对象的引用地址拷贝给形参。

Java中的对象传递，如果是修改引用，是不会对原来的对象有任何影响的。但是如果直接修改共享对象的属性的值，是会对原来的对象有影响的。



##### 总结

我们知道，编程语言中需要进行方法间的参数传递，这个传递的策略叫做传值策略。

在程序设计中，比较常见的就是值传递和引用传递。还有一种值传递的特例——共享对象传递。

值传递和引用传递最大的区别是传递的过程有没有复制出一个副本。如果是传递副本，就是值传递。否则就是引用传递。

在Java中，其实是通过值传递实现的参数传递，只不过对于Java对象的传递，传递的内容是对象的引用。

> 我们可以总结说，Java中的求值策略是共享对象传递，这是完全正确的。也可以说Java中只有值传递，只不过传递的内容是对象的引用。

> 但是！绝对不能人为Java中有引用传递。



## Java基础知识

### 基本数据类型

**8种基本数据类型**，分为三大类

字符型：char

布尔型：boolean

数值型：

1. 整形：byte、short、int、long
2. 浮点型：float、double



>String 不是基本数据类型，是引用类型。



**什么是浮点型？**

为了解决部分小数无法使用二进制精确表示的问题，采纳IEEE 754规范（二进制浮点数算术标准）。

> 浮点数和小数不是完全一样的，计算机中小数的表示法，其实有丁点和浮点两种，因为在位数相同的情况下，定点数的标识范围要比浮点数小。所以在计算机科学中，使用浮点数来标识实数的近似值。

IEEE 754规定了四种标识浮点数值的方式：

1. 单精确度（32位）
2. 双精确度（64位）
3. 延伸单精确度（43比特以上，很少使用）
4. 延伸双精确度（79比特以上，通常以80位实现）

其中最常用的就是32位单精度浮点数和64位双精度浮点数。

IEEE并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。



**什么是单精度和双精度？**

**单精度浮点数**在计算机存储器中占用4个字节（32bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。

**双精度浮点数**（double）使用64为（8字节）来存储一个浮点数。



**浮点型不能表示金额，建议使用BigDecimal或者Long（单位为分）来标识金额**



### 自动拆装箱

#### 基本数据类型有什么好处

new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。

**基本数据类型直接储存在栈内存中，更高效。**



#### 包装类型

Java 语言是一个面向对象的语言，但是 Java 中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表。

包装类均位于 `java.lang` 包，包装类和基本数据类型的对应关系如下表所示

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| byte         | Byte      |
| boolean      | Boolean   |
| short        | Short     |
| char         | Character |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |



#### 为什么需要包装类

很多人会有疑问，既然 Java 中为了提高效率，提供了八种基本数据类型，为什么还要提供包装类呢？

这个问题，其实前面已经有了答案，因为 Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。

为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。



#### 自动拆箱与自动装箱

在 Java SE5 中，为了减少开发人员的工作，Java 提供了自动拆箱与自动装箱功能。

自动装箱: 就是将基本数据类型自动转换成对应的包装类。

自动拆箱：就是将包装类自动转换成对应的基本数据类型。

```java
    Integer i = 10;  //自动装箱
    int b = i;     //自动拆箱
```



#### 自动装箱与自动拆箱的实现原理

我们有以下自动拆装箱的代码：

```java
    public static  void main(String[]args){
        Integer integer=1; //装箱
        int i=integer; //拆箱
    }复制ErrorOK!
```

对以上代码进行反编译后可以得到以下代码：

```java
    public static  void main(String[]args){
        Integer integer=Integer.valueOf(1);
        int i=integer.intValue();
    }复制ErrorOK!
```

从上面反编译后的代码可以看出，int 的自动装箱都是通过 `Integer.valueOf()` 方法来实现的，Integer 的自动拆箱都是通过 `integer.intValue` 来实现的。如果读者感兴趣，可以试着将八种类型都反编译一遍 ，你会发现以下规律：

> 自动装箱都是通过包装类的 `valueOf()` 方法来实现的.自动拆箱都是通过包装类对象的 `xxxValue()` 来实现的。



#### 自动拆装箱与缓存

我们只需要知道，当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象。

在 Boxing Conversion 部分的 Java 语言规范(JLS)规定如下：

如果一个变量 p 的值是：

- -128 至 127 之间的整数 (§3.10.1)
- true 和 false 的布尔值 (§3.10.3)
- `\u0000` 至 `\u007f` 之间的字符 (§3.10.4)

范围内的时，将 p 包装成 a 和 b 两个对象时，可以直接使用 a == b 判断 a 和 b 的值是否相等。



#### 自动拆装箱带来的问题

包装对象的数值比较，不能简单的使用 `==`，虽然 -128 到 127 之间的数字可以，但是这个范围之外还是需要使用 `equals` 比较。

前面提到，有些场景会进行自动拆装箱，同时也说过，由于自动拆箱，如果包装类对象为 null ，那么自动拆箱时就有可能抛出 NPE（空指针）。

如果一个 for 循环中有大量拆装箱操作，会浪费很多资源。



**如何正确定义接口的返回值(boolean/Boolean)类型及命名(success/isSuccess)**

**总结**

在定义一个布尔类型的变量，尤其是一个给外部提供的接口返回值时，要使用success来命名（而非isSuccess），阿里巴巴Java开发手册建议使用封装类来定义POJO和RPC返回值中的变量。但是这不意味着可以随意的使用null，我们还是要尽量避免出现对null的处理的。



### String

#### 字符串的不可变性

一旦一个String对象在堆内存中被创建出来，他就无法被修改。而且，String类的所有方法都没有改变字符串本身的值，都是返回一个新的的对象。

```java
String s = "abcd";
s = s.concat("ef");
```

![img](https://www.hollischuang.com/wp-content/uploads/2021/03/16163108328434.jpg)



> 为什么字符串要设计成不可变？

其实，主要是从缓存、安全性、线程安全和性能等角度触发的。

**缓存：**

代码中通常大量使用字符串，非常耗费资源。所以Java提供了对字符串的缓存功能，可以大大节省堆空间。

JVM中专门开辟了一部分空间来存储字符串，那就是字符串池。

通过字符串池，两个内容相同的字符串变量，可以从池中只想同一个字符串对象。从而节省了关键的内存资源。

```java
String s = "abcd";
String s2 = s;
```

![img](https://www.hollischuang.com/wp-content/uploads/2021/03/16163114985563.jpg)

如果字符串是不可变的，我们不用担心因为修改s的值而影响到s2。



**安全性：**

字符串在Java应用程序中广泛用于存储敏感信息，如用户名、密码、连接url、网络连接等。JVM类加载器在加载类的时也广泛地使用它。

因此，保护String类对于提升整个应用程序的安全性至关重要。



**线程安全：**

字符串是线程安全的，因为他是不可变的， 是线程共享的。



**hashcode缓存：**

字符串广泛应用于哈希实现，如HashMap,HashSet等。在对这些散列实现操作时，经常回调用hashCode()方法。

不可变行保证了字符串的值不会改变。因此，hashCode()方法在String类中被重写，以方便缓存，这样在第一次hashCode()调用期间计算和缓存散列，并从那是起返回相同的值。



**总结：**

字符串是不可变的，因此它们的引用可以被视为普通变量，可以在方法之间和线程之间传递它们，而不必担心它所指向的实际字符串对象是否会改变。

我们还了解了促使Java语言设计人员将该类设置为不可变类的其他原因。主要考虑的是缓存、安全性、线程安全和性能等方面



#### JDK6和JDK7中substring的原理及区别

**substring() 的作用**

`substring(int beginIndex, int endIndex)`方法截取字符串并返回其[beginIndex,endIndex-1]范围内的内容。



**JDK6中substring导致的问题**

如果一个很长很长的字符串，当你使用substring进行切割的时候你只需要很短的一段。可能导致性能问题，因为你只用一小段字符序列，却引用了整个字符串（**因为这个非常长的字符串一直在被引用，无法回收，就可能导致内存泄露**）。

> 内存泄露：在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。



JDK7中的substring

jdk7中，substring方法会在堆内存中创建一个新的数组。避免了对老字符串的引用，从而避免了内存泄露的问题。

![string-substring-jdk7](http://www.programcreek.com/wp-content/uploads/2013/09/string-substring-jdk71-650x389.jpeg)



#### replaceFirst、replaceAll、replace区别

```java
String string = "abc123adb23456aa";
System.out.println(string);//abc123adb23456aa

//使用replace将a替换成H
System.out.println(string.replace("a","H"));//Hbc123Hdb23456HH
//使用replaceFirst将第一个a替换成H
System.out.println(string.replaceFirst("a","H"));//Hbc123adb23456aa
//使用replace将a替换成H
System.out.println(string.replaceAll("a","H"));//Hbc123Hdb23456HH

//使用replaceFirst将第一个数字替换成H
System.out.println(string.replaceFirst("\\d","H"));//abcH23adb23456aa
//使用replaceAll将所有数字替换成H
System.out.println(string.replaceAll("\\d","H"));//abcHHHadbHHHHHaa
```



#### String对于“+”的重载

Java中拼接字符串，最简单的方法是使用“+”连接两个字符串。

还是这样一段代码。我们把他生成的字节码进行反编译，看看结果。

```java
String wechat = "Hollis";
String introduce = "每日更新Java相关技术文章";
String hollis = wechat + "," + introduce;
```

反编译后的内容如下

```java
String wechat = "Hollis";
String introduce = "\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6587\u7AE0";//每日更新Java相关技术文章
String hollis = (new StringBuilder()).append(wechat).append(",").append(introduce).toString();
```

通过反编译我们发现，拼接的过程是将String转成了StringBuilder后，使用append方法进行处理。



还有一种特殊情况，两个固定的字面量拼接如下

```java
String s = "a" + "b"
```

编译期会进行常量折叠，直接变成String s = “ab”。（因为两个都是编译期常量，编译期可知）



#### 字符串拼接的几种方法

下面是方法以及原理，先直接上总结

>1. 如果只是简单的字符串拼接，考虑直接使用"+"即可。
>2. 如果是在for循环中进行字符串拼接，考虑使用`StringBuilder`和`StringBuffer`。
>3. 如果在并发场景中进行字符串拼接的话，要使用`StringBuffer`。
>4. 如果是通过一个`List`进行字符串拼接，则考虑使用`StringJoiner`。



常用的字符串拼接方式有五种，分别是使用`+`、使用`concat`、使用`StringBuilder`、使用`StringBuffer`以及使用`StringUtils.join`。





**使用 concat方法**

```java
String wechat = "Hollis";
String introduce = "每日更新Java相关技术文章";
String hollis = wechat.concat(",").concat(introduce);

```

**使用`+`拼接字符串**

```java
String wechat = "Hollis";
String introduce = "每日更新Java相关技术文章";
String hollis = wechat + "," + introduce;
```

**StringBuffer**

```java
StringBuffer wechat = new StringBuffer("Hollis");
String introduce = "每日更新Java相关技术文章";
StringBuffer hollis = wechat.append(",").append(introduce);
```

**StringBuilder**

```java
StringBuilder wechat = new StringBuilder("Hollis");
String introduce = "每日更新Java相关技术文章";
StringBuilder hollis = wechat.append(",").append(introduce);
```

**StringUtils.join**

除了JDK中内置的字符串拼接方法，还可以使用一些开源类库中提供的字符串拼接方法名，如`apache.commons中`提供的`StringUtils`类，其中的`join`方法可以拼接字符串。

```java
String wechat = "Hollis";
String introduce = "每日更新Java相关技术文章";
System.out.println(StringUtils.join(wechat, ",", introduce));
```

```java
String []list  ={"Hollis","每日更新Java相关技术文章"};
String result= StringUtils.join(list,",");
System.out.println(result);
//结果：Hollis,每日更新Java相关技术文章
```



#### StringBuffer和StringBuilder的实现原理

和String类类似，StringBuilder也封装了一个字符数组。

**与String不同的是，他并不是final的，是可修改的。另外，字符数组中不一定所有位置都被使用，他有一个实例变量，来表示数组中已经使用的字符个数。**

其append源码如下：

```java
public StringBuilder append(String str) {
    super.append(str);
    return this;
}

```

该类继承了`AbstractStringBuilder`类，看下其`append`方法：

```java
public AbstractStringBuilder append(String str) {
    if (str == null)
        return appendNull();
    int len = str.length();
    ensureCapacityInternal(count + len);
    str.getChars(0, len, value, count);
    count += len;
    return this;
}
```

append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。

```java
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```

`StringBuffer`和`StringBuilder`类似，最大的区别就是`StringBuffer`是线程安全的，看一下`StringBuffer`的`append`方法。

```java
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```

**该方法使用`synchronized`进行声明，说明是一个线程安全的方法。**

**而`StringBuilder`则不是线程安全的。**



#### 为什么需要StringJoiner

如果要遍历一个list，并拼接字符串，我们可以采用下面这种方法。性能会更好

```java
list.stream().collect(Collectors.joining(":"))
```

StringJoiner其实是通过StringBuilder实现的，所以他的性能和StringBuilder差不多，他也是非线程安全的。



#### 字符串池

创建字符串的两种方式

```java
String str = "Hollis"; //字面量

String str = new String("Hollis")；
```

JVM中会单独开辟了一块内存，用来存储字符串常量。这个内存区域叫做字符串常量池。

**当代码出现字面量创建字符串对象时，JVM会先对这个字符串进行检查，如果字符串常量池中出现相同内容的字符串对象引用，则将这个引用返回。否则，创建新的字符串对象，然后将其放入字符串常量池，并返回该引用。**



**字符串常量池在JVM中的位置**

在JDK7以前，在永久代中。

JDK8中，移除了永久代，使用元空间代替了永久代，所以字符串常量池被放入了元空间。



#### Class常量池

在Java体系中，共有三种常量池

- 字符串常量池
- Class常量池
- 运行时常量池



##### 定义

Class常量池可以理解为是Class文件中的资源仓库。

Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（constant pool table）,用于存放编译器生成的各种**字面量**和**符号引用**。



**字面量**：

字面量就是指由字母、数字等构成的字符串或者数值。

```java
int a = 123;
String s = "hollis";
```

**符号引用**

符号引用是编译原理中的概念，是相对于直接引用来说的。

**主要包含了以下三类常量：**

1. *类和接口的全限定名
2. *字段的名称和描述符
3. *方法的名称和描述符

> 这也就可以印证前面的常量池中还包含一些`com/hollis/HelloWorld`、`main`、`([Ljava/lang/String;)V`等常量的原因了。



##### Class常量池有什么作用

大概意思就是：Class是用来保存常量的一个媒介场所，并且是一个中间场所。在JVM真的运行时，需要把常量池中的常量加载到内存中。

> 至于到底哪个阶段会做这件事情，以及Class常量池中的常量会以何种方式被加载到具体什么地方后续在补充



#### 运行时常量池

##### 定义

运行时常量池（Runtime Constant Pool）是每一个类或者接口的常量池（Constant_Pool）的运行时表示形式。

**包含的常量：**

从编译期可知的数值字面量到必须运行期解析后才能获得的方法或字段引用。

每一个运行时常量池都分配在Java虚拟机的**方法区**之中。在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。



**运行时常量池在JDK各个版本中的实现**

在不同版本的JDK中，运行时常量池所处的位置不一样。

在JDK 1.7之前，方法区位于堆内存的**永久代**中，运行时常量池作为方法区的一部分，也处于永久代中。

**因为使用永久代实现方法区可能导致内存泄露问题**，所以，从JDK1.7开始，JVM尝试解决这一问题，在1.7中，**将原本位于永久代中的运行时常量池移动到堆内存中**。（永久代在JDK 1.7并没有完全移除，只是原来方法区中的运行时常量池、类的静态变量等移动到了堆内存中。）

**在JDK 1.8中，彻底移除了永久代，方法区通过元空间的方式实现。随之，运行时常量池也在元空间中实现。**



**运行时常量池中常量的来源**

运行时常量池中的内容包含：

- Class常量池中的常量

- 字符串常量池中的内容



**运行时常量池、Class常量池、字符串常量池的区别与联系**

虚拟机启动过程中，会将各个Class文件中的常量池载入到运行时常量池中。

所以， Class常量池只是一个媒介场所。在JVM真的运行时，需要把常量池中的常量加载到内存中，进入到运行时常量池。

字符串常量池可以理解为运行时常量池分出来的部分。加载时，对于class的静态常量池，如果字符串会被装到字符串常量池中。